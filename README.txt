k-shiritori.rb : k 一般化しりとりソルバ
generate.rb    : k 一般化しりとり可能な単語集合を生成

========

ピーFI夏のインターン2012に応募した後輩に教えてもらった問題。

定義：

単語 w の後に単語 u が k 接続可能
<=> w の k-suffix と u の k-preffix が一致する

単語 w の後に単語 u が k 以下接続可能
<=> w と u が q 接続可能となる 1 <= q <= k が存在する

単語列 w1,..,wn は k 一般化しりとり列である
<=> すべての wi, wi+1 が k 以下接続可能


問題：

単語集合が与えられたとき、それらの全単語を含む k 一般化しりとり列が存在
するか判定する。ただし存在すると答えた場合はその例を１つ示す。


解法：

色々あると思いますが、有向グラフのハミルトン路発見問題に落としました。
まず、単語を節点に持つようなグラフを考える。全単語ペア (w, u) に関して
w の後に u が k 以下接続可能であれば辺 w -> u を追加する。こうしてでき
た有向グラフの各節点を丁度１度通る有向パスは k 一般化しりとり列である。

具体的には２つの方法でこのパスを発見しました。１つは最長パスを発見する
方法。これはほぼ普通のダイクストラですね。この方法は実装が簡単ですが、
判定問題と無関係な最長パスを探索しているという点で効率が悪いです。

２つ目の方法は単語の部分集合 W とその要素の１つ w の組　(w, W) を考え、
「w を始点とする W のハミルトン路はあるか」を繰り返し解く方法です。ある
w -> u なる u \in W を考えたとき、(u, W-{w}) がハミルトン路を持てば
(w, W) もハミルトン路を持ちます。この方法では (w, W) がハミルトン路を持
つとわかった時、そのきっかけとなった u を記憶することで最終的なハミルト
ン路を復元する事ができます。そして (w, W) を一度評価したらその結果を記
録することで再計算を防ぎます。

実際にこれら２つの方法を比較すると、後者のほうが圧倒的に高速に解けるこ
とが分かります。


